name: CI + Release (Ultimate — Must-Release, Matrix, Upgrades, Stable Runners)

on:
  push:
    branches: [ "main" ]
    tags:
      - "v*.*.*"                # tag push → release
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_enable:
        description: "수동 실행 시 릴리스 생성 (true/false)"
        required: true
        default: "false"
      prerelease:
        description: "프리릴리스 표시 (true/false)"
        required: true
        default: "false"
      generate_notes:
        description: "GitHub 자동 릴리스 노트 병행 (true/false)"
        required: true
        default: "true"
      force_version:
        description: "강제 버전(예: 1.4.0) — 비우면 자동 SemVer(vX.Y.Z)"
        required: false
        default: ""
      extra_assets:
        description: "추가 업로드 글롭(세미콜론 구분, 예: dist/*.tar.gz;bin/*.zip)"
        required: false
        default: ""
      draft_release:
        description: "릴리스를 draft로 생성 (true/false)"
        required: true
        default: "false"
      create_tag:
        description: "수동 릴리스 시 태그 자동 생성/푸시 (true/false)"
        required: true
        default: "true"
      tag_prefix:
        description: "자동 태그 접두어 (예: v)"
        required: false
        default: "v"
      sbom_enable:
        description: "SBOM 생성/첨부 (true/false)"
        required: true
        default: "true"
      checksum_enable:
        description: "SHA256 체크섬 생성/첨부 (true/false)"
        required: true
        default: "true"

permissions:
  contents: write

env:
  # 공통 재시도 헬퍼(모든 잡에서 부트스트랩)
  RETRY_SCRIPT: |
    #!/usr/bin/env bash
    set -Eeuo pipefail
    max="$1"; shift; sleep_s="$1"; shift; n=0
    until "$@"; do
      n=$((n+1))
      if [ "$n" -ge "$max" ]; then
        echo "[RETRY] give up: $*"; exit 1
      fi
      echo "[RETRY] $n/$max failed: $* — sleep ${sleep_s}s"; sleep "$sleep_s"
    done

jobs:
  build_matrix:
    name: 빌드(${{ matrix.os }})
    # 러너 마이그레이션 경고 제거 위해 명시 고정
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-15, windows-2025]

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bootstrap retry helper
        shell: bash
        run: |
          echo "$RETRY_SCRIPT" > .retry.sh
          chmod +x .retry.sh

      - name: 준비_출시 / 환경 업그레이드 (각 OS)
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "[INFO] 준비_출시"
          case "${{ runner.os }}" in
            Linux)
              ./\.retry.sh 3 10 sudo apt-get update
              ./\.retry.sh 3 10 sudo apt-get -y upgrade
              ;;
            macOS)
              ./\.retry.sh 3 10 brew update
              ./\.retry.sh 3 10 brew upgrade
              ;;
            Windows)
              ./\.retry.sh 3 10 choco upgrade all -y
              ;;
          esac
          echo "[OK] OS upgrade completed"

      - name: Hello from ${{ runner.os }}
        run: echo "Hello from ${{ runner.os }}!"

      - name: Build placeholder (replace with real build)
        run: |
          echo "Build your project here for ${{ runner.os }}"

      - name: Produce per-OS artifact
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p out
          echo "OS=${{ runner.os }}" > "out/info-${{ runner.os }}.txt"
          if [ "${{ runner.os }}" = "Linux" ]; then
            mkdir -p release
            zip -r release/source.zip . -x ".git/*" || true
          fi

      - name: Upload per-OS artifact
        uses: actions/upload-artifact@v4
        with:
          name: bundle-${{ runner.os }}
          path: |
            out/**
            release/source.zip
          if-no-files-found: ignore

  prepare_release:
    needs: [build_matrix]
    runs-on: ubuntu-24.04
    outputs:
      should_release: ${{ steps.meta.outputs.should_release }}
      tag:            ${{ steps.meta.outputs.tag }}
      title:          ${{ steps.meta.outputs.title }}
      prerelease:     ${{ steps.meta.outputs.prerelease }}
      generate_notes: ${{ steps.meta.outputs.generate_notes }}
      draft:          ${{ steps.meta.outputs.draft }}
      notes_path:     ${{ steps.notes.outputs.notes_path }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bootstrap retry helper
        shell: bash
        run: |
          echo "$RETRY_SCRIPT" > .retry.sh
          chmod +x .retry.sh

      - name: Inspect repo state (safe)
        id: repoinfo
        shell: bash
        run: |
          set -Eeuo pipefail
          commits="0"
          if git rev-parse --verify HEAD >/dev/null 2>&1; then
            commits="$(git rev-list --count HEAD 2>/dev/null || echo 0)"
          fi
          echo "commit_count=$commits" >> "$GITHUB_OUTPUT"

      - name: Compute next version & changelog (dry run)
        id: semver
        if: ${{ steps.repoinfo.outputs.commit_count != '0' }}
        uses: TriPSs/conventional-changelog-action@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          release-count: 0
          skip-commit: true
          skip-tag: true
          output-file: false
          preset: conventionalcommits

      - name: Map SemVer (fallback / tag-bump safe)
        id: semvermap
        shell: bash
        run: |
          set -Eeuo pipefail
          bump_patch() {
            local t="$1"; t="${t#v}"; IFS='.' read -r MA MI PA <<< "$t"
            MA="${MA:-0}"; MI="${MI:-1}"; PA="${PA:-0}"
            PA=$((PA+1)); echo "v${MA}.${MI}.${PA}"
          }
          prefix="${{ github.event.inputs.tag_prefix || 'v' }}"
          if [ "${{ steps.repoinfo.outputs.commit_count }}" = "0" ]; then
            NEXT="${prefix}0.1.0"; CLEAN=""
            echo "[WARN] SemVer 제거 실패 → fallback ${NEXT}"
          else
            ver="${{ steps.semver.outputs.version }}"
            CLEAN="${{ steps.semver.outputs.clean_changelog }}"
            if [ -z "$ver" ] || [ "$ver" = "null" ]; then
              latest="$(git tag -l "${prefix}*" --sort=-v:refname | head -n1 || true)"
              if [ -z "$latest" ]; then
                NEXT="${prefix}0.1.0"
              else
                NEXT="$(bump_patch "$latest")"
              fi
              echo "[WARN] SemVer 계산 실패 → fallback ${NEXT}"
            else
              NEXT="${prefix}${ver}"
            fi
          fi
          echo "next=${NEXT}" >> "$GITHUB_OUTPUT"
          echo "clean_changelog=${CLEAN}" >> "$GITHUB_OUTPUT"

      - name: Decide release metadata (Must release)
        id: meta
        shell: bash
        run: |
          set -Eeuo pipefail
          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"
          BR="${{ github.ref_name }}"
          INPUT_ENABLE="${{ github.event.inputs.release_enable || '' }}"
          INPUT_PRE="${{ github.event.inputs.prerelease || 'false' }}"
          INPUT_NOTES="${{ github.event.inputs.generate_notes || 'true' }}"
          INPUT_DRAFT="${{ github.event.inputs.draft_release || 'false' }}"
          FORCE_VER="${{ github.event.inputs.force_version || '' }}"
          SHOULD="false"; TAG=""; TITLE=""; DRAFT="$INPUT_DRAFT"

          ./.retry.sh 3 10 git fetch origin main --tags

          if [[ "$EVENT" == "push" && "$REF" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
            TAGSHA="$(git rev-list -n1 "$TAG")"
            # main 히스토리에 포함 필수
            if git merge-base --is-ancestor "$TAGSHA" origin/main; then
              SHOULD="true"; TITLE="$TAG"
            else
              echo "::error::Tag ${TAG} is not on main history"; exit 1
            fi
          fi

          if [[ "$EVENT" == "workflow_dispatch" && "${INPUT_ENABLE,,}" == "true" ]]; then
            # 브랜치가 main이 아니어도 반드시 릴리스: origin/main HEAD에 태그 박고 릴리스
            TARGET_SHA="$(git rev-parse origin/main)"
            if [ -z "$FORCE_VER" ]; then
              TAG="${{ steps.semvermap.outputs.next }}"
            else
              TAG="${{ github.event.inputs.tag_prefix || 'v' }}${FORCE_VER}"
            fi
            echo "target_sha=$TARGET_SHA" >> "$GITHUB_OUTPUT"
            SHOULD="true"; TITLE="Release ${TAG}"
          fi

          echo "should_release=$SHOULD"         >> "$GITHUB_OUTPUT"
          echo "tag=$TAG"                       >> "$GITHUB_OUTPUT"
          echo "title=$TITLE"                   >> "$GITHUB_OUTPUT"
          echo "prerelease=$INPUT_PRE"          >> "$GITHUB_OUTPUT"
          echo "generate_notes=$INPUT_NOTES"    >> "$GITHUB_OUTPUT"
          echo "draft=$DRAFT"                   >> "$GITHUB_OUTPUT"

      - name: Ensure tag exists (manual:tag on origin/main HEAD)
        if: ${{ steps.meta.outputs.should_release == 'true' && contains(github.event_name, 'workflow_dispatch') && github.event.inputs.create_tag == 'true' }}
        env:
          TAG: ${{ steps.meta.outputs.tag }}
          TARGET_SHA: ${{ steps.meta.outputs.target_sha }}
        shell: bash
        run: |
          set -Eeuo pipefail
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "[TAG] exists: $TAG"
          else
            echo "[TAG] creating on origin/main: $TAG @ $TARGET_SHA"
            git tag -a "$TAG" "$TARGET_SHA" -m "Automated tag $TAG (origin/main)"
            git push origin "$TAG"
          fi

      - name: Write changelog to file
        id: notes
        if: ${{ steps.meta.outputs.should_release == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p release
          notes_input="${{ steps.semvermap.outputs.clean_changelog }}"
          if [ -z "$notes_input" ] || [ "$notes_input" = "null" ]; then
            echo "Automated release for ${{ steps.meta.outputs.tag }}" > release/CHANGELOG.md
          else
            printf "%s\n" "$notes_input" > release/CHANGELOG.md
          fi
          echo "notes_path=release/CHANGELOG.md" >> "$GITHUB_OUTPUT"

  release:
    needs: [prepare_release]
    if: ${{ needs.prepare_release.outputs.should_release == 'true' }}
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bootstrap retry helper
        shell: bash
        run: |
          echo "$RETRY_SCRIPT" > .retry.sh
          chmod +x .retry.sh

      - name: Download ALL artifacts (matrix merge)
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: Generate SHA256 checksums (optional)
        if: ${{ github.event.inputs.checksum_enable == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          cd release
          find . -type f ! -name "SHA256SUMS.txt" -exec sha256sum "{}" \; | sort -k2 > SHA256SUMS.txt
          echo "[CSUM] release/SHA256SUMS.txt created"

      - name: Generate SBOM (SPDX) (optional)
        if: ${{ github.event.inputs.sbom_enable == 'true' }}
        uses: anchore/sbom-action@v0
        with:
          path: .
          format: spdx-json
          output-file: release/SBOM.spdx.json

      - name: Create/Update GitHub Release (must)
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ needs.prepare_release.outputs.tag }}
          name: ${{ needs.prepare_release.outputs.title }}
          draft: ${{ needs.prepare_release.outputs.draft }}
          prerelease: ${{ needs.prepare_release.outputs.prerelease }}
          allowUpdates: true
          generateReleaseNotes: ${{ needs.prepare_release.outputs.generate_notes }}
          artifacts: |
            release/**
          artifactErrorsFailBuild: true

      - name: Upload extra assets via gh (from inputs.extra_assets)
        if: ${{ github.event.inputs.extra_assets != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.prepare_release.outputs.tag }}
        shell: bash
        run: |
          set -Eeuo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y gh
          fi
          IFS=';' read -r -a arr <<< "${{ github.event.inputs.extra_assets }}"
          for g in "${arr[@]}"; do
            [ -z "$g" ] && continue
            matched="no"
            for f in $g; do
              if [ -e "$f" ]; then
                matched="yes"
                echo "[UPLOAD] $f"
                ./.retry.sh 3 10 gh release upload "$TAG" "$f" --clobber
              fi
            done
            if [ "$matched" = "no" ]; then
              echo "::error::No files matched extra_assets pattern: $g"; exit 1
            fi
          done
