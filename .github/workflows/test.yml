name: CI + Release (Resilient, SemVer, Changelog, Multi-asset)

on:
  push:
    branches: [ "main" ]
    tags:
      - "v*.*.*"        # tag push -> release
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_enable:
        description: "수동 실행 시 릴리스 생성 (true/false)"
        required: true
        default: "false"
      prerelease:
        description: "프리릴리스 표시 (true/false)"
        required: true
        default: "false"
      generate_notes:
        description: "GitHub 자동 릴리스 노트 병행 (true/false)"
        required: true
        default: "true"
      force_version:
        description: "강제 버전(예: 1.4.0) — 비우면 자동 SemVer"
        required: false
        default: ""
      extra_assets:
        description: "추가 업로드 글롭(세미콜론 구분, 예: dist/*.tar.gz;bin/*.zip)"
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run a one-line script
        run: echo Hello, world!

      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.

      # 예시: 소스 스냅샷 번들 (원하면 실제 빌드 산출물로 교체)
      - name: Make default release bundle
        run: |
          mkdir -p release
          git rev-parse --short HEAD > release/COMMIT.txt
          zip -r release/source.zip . -x ".git/*" || true

      - name: Upload CI artifact
        uses: actions/upload-artifact@v4
        with:
          name: ci-bundle
          path: release/source.zip
          if-no-files-found: ignore

  prepare_release:
    needs: [build]
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.meta.outputs.should_release }}
      tag:            ${{ steps.meta.outputs.tag }}
      title:          ${{ steps.meta.outputs.title }}
      prerelease:     ${{ steps.meta.outputs.prerelease }}
      generate_notes: ${{ steps.meta.outputs.generate_notes }}
      notes_path:     ${{ steps.notes.outputs.notes_path }}
      artifacts_list: ${{ steps.assets.outputs.artifacts_list }}
    steps:
      - uses: actions/checkout@v4

      # 최신 태그 조회(없으면 무시)
      - name: Get latest tag (best-effort)
        id: latest
        continue-on-error: true
        uses: actions-ecosystem/action-get-latest-tag@v1

      # SemVer & Changelog 계산(Conventional Commits, 태그/커밋 메시지 기반)
      - name: Compute next version & changelog (dry run)
        id: semver
        continue-on-error: true
        uses: TriPSs/conventional-changelog-action@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          release-count: 0
          skip-commit: true
          skip-tag: true
          output-file: false
          preset: conventionalcommits

      # 원하는 출력 키로 매핑 (예: steps.semvermap.outputs.next → vX.Y.Z)
      - name: Map semver output
        id: semvermap
        shell: bash
        run: |
          set -euo pipefail
          ver="${{ steps.semver.outputs.version }}"
          [ -z "$ver" ] && ver="0.1.0"
          echo "next=v${ver}" >> "$GITHUB_OUTPUT"

      # 릴리스 여부/메타 결정 + main 분기 필터
      - name: Decide release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"
          BR="${{ github.ref_name }}"
          INPUT_ENABLE="${{ github.event.inputs.release_enable || '' }}"
          INPUT_PRE="${{ github.event.inputs.prerelease || 'false' }}"
          INPUT_NOTES="${{ github.event.inputs.generate_notes || 'true' }}"
          FORCE_VER="${{ github.event.inputs.force_version || '' }}"
          SHOULD="false"
          TAG=""
          TITLE=""

          # 기본: ONLY main에서 릴리스
          # 태그 푸시면 그 태그 커밋이 main에 포함되는지 검증
          git fetch origin main --depth=1 || true

          if [[ "$EVENT" == "push" && "$REF" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
            # 태그 커밋이 main에 포함? (안되면 릴리스 스킵)
            if git merge-base --is-ancestor "$(git rev-list -n1 "$TAG")" origin/main; then
              SHOULD="true"
            else
              echo "[META] Tag $TAG is not on main history -> skip release"
            fi
            TITLE="$TAG"
          elif [[ "$EVENT" == "workflow_dispatch" && "${INPUT_ENABLE,,}" == "true" ]]; then
            # 수동 릴리스는 현재 HEAD가 main일 때만
            if [[ "$BR" == "main" ]]; then
              SHOULD="true"
              if [[ -n "$FORCE_VER" ]]; then
                TAG="v${FORCE_VER}"
              else
                TAG="${{ steps.semvermap.outputs.next }}"
              fi
              TITLE="Release ${TAG}"
            else
              echo "[META] manual release allowed only on main -> current: $BR"
            fi
          fi

          echo "should_release=$SHOULD"         >> "$GITHUB_OUTPUT"
          echo "tag=$TAG"                       >> "$GITHUB_OUTPUT"
          echo "title=$TITLE"                   >> "$GITHUB_OUTPUT"
          echo "prerelease=$INPUT_PRE"          >> "$GITHUB_OUTPUT"
          echo "generate_notes=$INPUT_NOTES"    >> "$GITHUB_OUTPUT"

      # 체인지로그를 파일로 저장 (릴리스 노트에 첨부)
      - name: Write changelog to file
        id: notes
        if: ${{ steps.meta.outputs.should_release == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release
          # TriPSs 출력 clean_changelog가 없으면 간단한 메시지 대체
          notes="${{ steps.semver.outputs.clean_changelog }}"
          if [[ -z "$notes" || "$notes" == "null" ]]; then
            echo "Automated release for ${{ steps.meta.outputs.tag }}" > release/CHANGELOG.md
          else
            printf "%s\n" "$notes" > release/CHANGELOG.md
          fi
          echo "notes_path=release/CHANGELOG.md" >> "$GITHUB_OUTPUT"

      # 기본 번들 + 사용자가 지정한 추가 자산 경로 수집
      - name: Collect assets list
        id: assets
        if: ${{ steps.meta.outputs.should_release == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release
          # 기본 자산
          LIST="release/source.zip"$'\n'"${{ steps.notes.outputs.notes_path }}"
          # 추가 글롭 (세미콜론 구분)
          EXTRA="${{ github.event.inputs.extra_assets || '' }}"
          IFS=';' read -r -a arr <<< "$EXTRA"
          for g in "${arr[@]}"; do
            [[ -z "$g" ]] && continue
            # 글롭 확장 (있을 때만)
            for f in $g; do
              if [[ -f "$f" || -d "$f" ]]; then
                LIST+=$'\n'"$f"
              fi
            done
          done
          echo "artifacts_list<<EOF" >> "$GITHUB_OUTPUT"
          echo "$LIST" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

  release:
    needs: [prepare_release]
    if: ${{ needs.prepare_release.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 빌드 자산 다운로드 (source.zip 등)
      - name: Download CI artifact (fallback)
        uses: actions/download-artifact@v4
        with:
          name: ci-bundle
          path: release
        continue-on-error: true

      # 자산 경로 파일화
      - name: Write artifact list to disk
        id: list
        run: |
          set -euo pipefail
          echo "${{ needs.prepare_release.outputs.artifacts_list }}" > artifacts.txt
          echo "Artifacts to upload:" && cat artifacts.txt

      # ncipollo/release-action으로 릴리스 생성/업데이트 + 다중 자산 업로드
      - name: Create/Update GitHub Release
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ needs.prepare_release.outputs.tag }}
          name: ${{ needs.prepare_release.outputs.title }}
          prerelease: ${{ needs.prepare_release.outputs.prerelease }}
          allowUpdates: true
          generateReleaseNotes: ${{ needs.prepare_release.outputs.generate_notes }}
          artifacts: |
            release/source.zip
            release/CHANGELOG.md
          artifactErrorsFailBuild: false

      # 추가 자산(글롭 확장분)도 업로드 (있을 때만)
      - name: Upload extra assets (loop)
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ needs.prepare_release.outputs.tag }}"
          # gh가 있으면 고급 업로드 시도
          if command -v gh >/dev/null 2>&1; then
            while IFS= read -r line; do
              [[ -z "$line" ]] && continue
              [[ "$line" == "release/source.zip" || "$line" == "release/CHANGELOG.md" ]] && continue
              if [[ -e "$line" ]]; then
                echo "[UPLOAD] $line"
                gh release upload "$TAG" "$line" --clobber || true
              fi
            done < artifacts.txt
          else
            echo "[INFO] gh CLI not found; extra asset upload skipped"
          fi
