name: "🧱 Enigma Bulk Folder & Disk Expander (Cron+Daemon+AutoMount+SafeInputs)"

on:
  workflow_dispatch:
    inputs:
      base_path:
        description: "생성 기준 경로 (repo 내부)"
        required: true
        default: ".github/echo_enigma"
      total_dirs:
        description: "총 생성할 디렉토리 수"
        required: true
        default: "500"
      depth:
        description: "중첩 폴더 깊이 (1~5)"
        required: true
        default: "3"
      fanout:
        description: "각 레벨당 자식 폴더 개수(분기)"
        required: true
        default: "5"
      files_per_dir:
        description: "각 디렉토리에 넣을 파일 개수(.keep/README 등)"
        required: true
        default: "1"
      do_disk_reclaim:
        description: "러너 디스크 공간 확보 수행 (true/false)"
        required: true
        default: "true"
      use_worktree_on_mnt:
        description: "/mnt에 worktree 생성해 대용량 작업 (true/false)"
        required: true
        default: "true"
      daemon_profile:
        description: "상주배치 모드 (off|fast|normal|slow)"
        required: true
        default: "off"
      advanced_opts:
        description: "고급 옵션(KEY=VALUE;KEY=VALUE...) 예: commit_message=chore;loopback_size_gb=16;extra_disk_device=/dev/sdb"
        required: false
        default: ""

  schedule:
    - cron: "*/5 * * * *"    # 5분마다
    - cron: "*/10 * * * *"   # 10분마다
    - cron: "*/15 * * * *"   # 15분마다

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: enigma-expander-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  expand:
    name: "Bulk Dir + Disk Prep"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Resolve inputs & defaults (cron-safe) + parse advanced_opts
        id: resolve
        shell: bash
        run: |
          set -Eeuo pipefail

          put() { echo "$1" >> "$GITHUB_ENV"; }

          # 1) 1차 주입 (schedule일 때는 빈 값일 수 있으므로 "")
          put "BASE_PATH=${{ github.event.inputs.base_path }}"
          put "TOTAL_DIRS=${{ github.event.inputs.total_dirs }}"
          put "DEPTH=${{ github.event.inputs.depth }}"
          put "FANOUT=${{ github.event.inputs.fanout }}"
          put "FILES_PER_DIR=${{ github.event.inputs.files_per_dir }}"
          put "DO_DISK_RECLAIM=${{ github.event.inputs.do_disk_reclaim }}"
          put "USE_WORKTREE=${{ github.event.inputs.use_worktree_on_mnt }}"
          put "DAEMON_PROFILE=${{ github.event.inputs.daemon_profile }}"
          put "ADV_OPTS_RAW=${{ github.event.inputs.advanced_opts }}"

          # 2) 기본값 강제(비어있으면 대입)
          : "${BASE_PATH:=".github/echo_enigma"}"
          : "${TOTAL_DIRS:="500"}"
          : "${DEPTH:="3"}"
          : "${FANOUT:="5"}"
          : "${FILES_PER_DIR:="1"}"
          : "${DO_DISK_RECLAIM:="true"}"
          : "${USE_WORKTREE:="true"}"
          : "${DAEMON_PROFILE:="off"}"

          # 3) advanced_opts 파싱: KEY=VALUE;KEY=VALUE...
          COMMIT_MSG="chore(enigma): bulk dir expansion + disk prep"
          LOOPBACK_SIZE_GB="8"
          EXTRA_DISK_DEVICE=""

          parse_kv () {
            local raw="$1"
            IFS=';' read -r -a pairs <<< "$raw"
            for p in "${pairs[@]}"; do
              [ -z "$p" ] && continue
              key="${p%%=*}"
              val="${p#*=}"
              case "$key" in
                commit_message)     COMMIT_MSG="$val" ;;
                loopback_size_gb)   LOOPBACK_SIZE_GB="$val" ;;
                extra_disk_device)  EXTRA_DISK_DEVICE="$val" ;;
              esac
            done
          }
          parse_kv "${ADV_OPTS_RAW:-}"

          # 4) 최종 환경으로 반영
          {
            echo "BASE_PATH=$BASE_PATH"
            echo "TOTAL_DIRS=$TOTAL_DIRS"
            echo "DEPTH=$DEPTH"
            echo "FANOUT=$FANOUT"
            echo "FILES_PER_DIR=$FILES_PER_DIR"
            echo "DO_DISK_RECLAIM=$DO_DISK_RECLAIM"
            echo "USE_WORKTREE=$USE_WORKTREE"
            echo "DAEMON_PROFILE=$DAEMON_PROFILE"
            echo "COMMIT_MSG=$COMMIT_MSG"
            echo "LOOPBACK_SIZE_GB=$LOOPBACK_SIZE_GB"
            echo "EXTRA_DISK_DEVICE=$EXTRA_DISK_DEVICE"
          } >> "$GITHUB_ENV"

      - name: Git safe.directory (권한 이슈 대비)
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE" || true

      - name: Show disk before
        run: |
          echo "[DISK][BEFORE]"; df -hT | sed 's/^/[DF] /' || true
          echo "[MEM]"; free -h || true

      - name: Reclaim disk space (GitHub-hosted)
        if: env.DO_DISK_RECLAIM == 'true'
        run: |
          set -Eeuo pipefail
          echo "[RECLAIM] Start"
          sudo swapoff -a || true
          sudo rm -f /swapfile || true
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache || true
          sudo docker system prune -af || true
          sudo docker volume prune -f || true
          sudo rm -rf /var/lib/docker || true
          sudo apt-get clean || true
          rm -rf ~/.cache || true
          echo "[RECLAIM] Done"; df -h | sed 's/^/[DF1] /'

      - name: Ensure mount tools
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo apt-get install -y tree parted util-linux e2fsprogs

      - name: Disk mount (device or loopback — ALWAYS mount)
        run: |
          set -Eeuo pipefail
          TARGET="/mnt/enigma-extra"
          DEV="${EXTRA_DISK_DEVICE:-}"
          SIZE="${LOOPBACK_SIZE_GB:-8}"

          if [ -n "$DEV" ] && [ -b "$DEV" ]; then
            echo "[MOUNT] Using physical device: $DEV"
            sudo parted -s "$DEV" mklabel gpt || true
            sudo parted -s "$DEV" mkpart primary ext4 0% 100% || true
            PART="$(lsblk -no PATH "$DEV" | tail -n1)1"; [ -b "$PART" ] || PART="${DEV}1"
            sudo mkfs.ext4 -F "$PART"
            sudo mkdir -p "$TARGET"
            sudo mount "$PART" "$TARGET"
            sudo chown -R "$USER:$USER" "$TARGET"
          else
            echo "[MOUNT] No block device; creating loopback disk ${SIZE}G"
            IMG="/mnt/enigma-extra.img"
            sudo fallocate -l "${SIZE}G" "$IMG" || sudo dd if=/dev/zero of="$IMG" bs=1M count=$((SIZE*1024))
            LOOP="$(sudo losetup -f --show "$IMG")"
            echo "[MOUNT] Loop device: $LOOP"
            sudo mkfs.ext4 -F "$LOOP"
            sudo mkdir -p "$TARGET"
            sudo mount "$LOOP" "$TARGET"
            sudo chown -R "$USER:$USER" "$TARGET"
          fi

          echo "[MOUNT] Mounted at $TARGET"
          df -hT "$TARGET" | sed 's/^/[MNT] /'

      - name: Prepare worktree on /mnt (충돌 안전)
        id: workdir
        run: |
          set -Eeuo pipefail
          BR="${{ github.ref_name }}"
          [ -n "$BR" ] || BR="$(git rev-parse --abbrev-ref HEAD)"
          RUNID="${{ github.run_id }}-${{ github.run_attempt }}"
          WTBR="wt-$RUNID"
          WTDIR="/mnt/enigma-work"
          WORKDIR="$GITHUB_WORKSPACE"
          USE="${USE_WORKTREE}"

          echo "base_branch=$BR" >> "$GITHUB_OUTPUT"

          if [ "$USE" = "true" ]; then
            echo "[WT] Requested worktree on $WTDIR for branch: $BR"
            sudo mkdir -p "$WTDIR"
            sudo chown -R "$USER:$USER" "$WTDIR"

            IN_USE="$(git worktree list --porcelain | sed -n 's/^branch //p' | grep -cx "refs/heads/$BR" || true)"
            git fetch --all --prune

            if [ "$IN_USE" != "0" ]; then
              echo "[WT] Branch '$BR' in use; create temp branch: $WTBR"
              git branch -f "$WTBR" "$BR"
              git worktree add "$WTDIR" "$WTBR"
              echo "worktree_branch=$WTBR" >> "$GITHUB_OUTPUT"
            else
              git worktree add "$WTDIR" "$BR"
              echo "worktree_branch=$BR" >> "$GITHUB_OUTPUT"
            fi
            WORKDIR="$WTDIR"
          else
            echo "[WT] Disabled; use current workspace"
            echo "worktree_branch=$BR" >> "$GITHUB_OUTPUT"
          fi

          echo "workdir=$WORKDIR" >> "$GITHUB_OUTPUT"
          echo "[WT] Workdir: $WORKDIR (branch: $(sed -n 's/^worktree_branch=//p' "$GITHUB_OUTPUT"))"

      - name: Generate enigma_expand.sh (no-heredoc)
        run: |
          set -Eeuo pipefail
          mkdir -p scripts
          {
            printf '%s\n' '#!/usr/bin/env bash'
            printf '%s\n' 'set -Eeuo pipefail'
            printf '%s\n' 'BASE_PATH="${BASE_PATH:-.github/echo_enigma}"'
            printf '%s\n' 'TOTAL_DIRS="${TOTAL_DIRS:-500}"'
            printf '%s\n' 'DEPTH="${DEPTH:-3}"'
            printf '%s\n' 'FANOUT="${FANOUT:-5}"'
            printf '%s\n' 'FILES_PER_DIR="${FILES_PER_DIR:-1}"'
            printf '%s\n' 'REPORT_DIR="${REPORT_DIR:-site/reports}"'
            printf '%s\n' 'LOG_DIR="${LOG_DIR:-.github/echo_enigma/logs}"'
            printf '%s\n' 'TS="$(date -u +%Y%m%dT%H%M%SZ)"'
            printf '%s\n' 'echo "[ECHO] BASE_PATH=$BASE_PATH TOTAL_DIRS=$TOTAL_DIRS DEPTH=$DEPTH FANOUT=$FANOUT FILES_PER_DIR=$FILES_PER_DIR"'
            printf '%s\n' 'mkdir -p "$BASE_PATH" "$REPORT_DIR" "$LOG_DIR"'
            printf '%s\n' 'REPORT_CSV="$REPORT_DIR/dir_report_$TS.csv"'
            printf '%s\n' 'TREE_LOG="$LOG_DIR/tree_$TS.log"'
            printf '%s\n' 'echo "seq,rel_path,created_files" > "$REPORT_CSV"'
            printf '%s\n' 'make_path_by_index () {'
            printf '%s\n' '  local idx="$1" depth="$2" fanout="$3"; local path=""; local rem="$idx"'
            printf '%s\n' '  for ((level=1; level<=depth; level++)); do'
            printf '%s\n' '    local d=$(( rem % fanout )); rem=$(( rem / fanout ))'
            printf '%s\n' '    path="${path}/l${level}_$(printf "%03d" "$d")"'
            printf '%s\n' '  done'
            printf '%s\n' '  printf "%s" "$path"'
            printf '%s\n' '}'
            printf '%s\n' 'created=0'
            printf '%s\n' 'for ((i=0; i<TOTAL_DIRS; i++)); do'
            printf '%s\n' '  rel="$(make_path_by_index "$i" "$DEPTH" "$FANOUT")/n$(printf "%05d" "$i")"'
            printf '%s\n' '  dir="$BASE_PATH$rel"; mkdir -p "$dir"; cnt=0'
            printf '%s\n' '  for ((f=1; f<=FILES_PER_DIR; f++)); do'
            printf '%s\n' '    echo "# keep: $TS $i $f" > "$dir/.keep.$f"; cnt=$((cnt+1))'
            printf '%s\n' '  done'
            printf '%s\n' '  if [ ! -f "$dir/README.md" ]; then'
            printf '%s\n' '    printf "%s\n" "# Enigma Node $(printf "%05d" "$i")" > "$dir/README.md"'
            printf '%s\n' '    printf "%s\n" "- Timestamp: $TS" >> "$dir/README.md"'
            printf '%s\n' '    printf "%s\n" "- Depth: $DEPTH / Fanout: $FANOUT" >> "$dir/README.md"'
            printf '%s\n' '    printf "%s\n" "- Auto-generated" >> "$dir/README.md"'
            printf '%s\n' '    cnt=$((cnt+1))'
            printf '%s\n' '  fi'
            printf '%s\n' '  echo "$i,$rel,$cnt" >> "$REPORT_CSV"'
            printf '%s\n' '  created=$((created+1))'
            printf '%s\n' 'done'
            printf '%s\n' 'echo "[ECHO] Created dirs: $created"'
            printf '%s\n' 'tree -a -L "$DEPTH" "$BASE_PATH" > "$TREE_LOG" || true'
            printf '%s\n' 'echo "[OK] report: $REPORT_CSV"'
            printf '%s\n' 'echo "[OK] tree:   $TREE_LOG"'
          } > scripts/enigma_expand.sh
          chmod +x scripts/enigma_expand.sh

      - name: One-shot run
        run: |
          set -Eeuo pipefail
          WDIR="${{ steps.workdir.outputs.workdir }}"
          cd "$WDIR"
          echo "[RUN][ONESHOT] $(pwd)/scripts/enigma_expand.sh"
          BASE_PATH="${BASE_PATH:-.github/echo_enigma}" TOTAL_DIRS="${TOTAL_DIRS:-500}" DEPTH="${DEPTH:-3}" \
          FANOUT="${FANOUT:-5}" FILES_PER_DIR="${FILES_PER_DIR:-1}" \
          REPORT_DIR="site/reports" LOG_DIR=".github/echo_enigma/logs" ./scripts/enigma_expand.sh

      - name: Commit & push (one-shot)
        id: commit_once
        run: |
          set -Eeuo pipefail
          WDIR="${{ steps.workdir.outputs.workdir }}"
          WTBR="${{ steps.workdir.outputs.worktree_branch }}"
          cd "$WDIR"

          CM="${COMMIT_MSG:-chore(enigma): bulk dir expansion + disk prep}"
          git -c user.name="github-actions[bot]" -c user.email="github-actions[bot]@users.noreply.github.com" \
              commit -m "$CM" -a || true

          if git diff --quiet HEAD; then
            echo "committed=false" >> "$GITHUB_OUTPUT"
          else
            git push origin "HEAD:$WTBR"
            echo "committed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Merge to base branch (FF → rebase → PR)
        if: steps.commit_once.outputs.committed == 'true'
        run: |
          set -Eeuo pipefail
          BASE="${{ steps.workdir.outputs.base_branch }}"
          WTBR="${{ steps.workdir.outputs.worktree_branch }}"
          echo "[MERGE] Base=$BASE, From=$WTBR"
          cd "$GITHUB_WORKSPACE"
          git fetch origin "$BASE" "$WTBR" --prune
          git checkout "$BASE"
          git pull --ff-only origin "$BASE" || true
          if git merge --ff-only "origin/$WTBR"; then
            git push origin "$BASE"
          else
            echo "[MERGE] FF failed, trying rebase ..."
            git rebase "origin/$WTBR" || REBASE_FAIL=1
            if [ "${REBASE_FAIL:-0}" = "1" ]; then
              NEWBR="enigma/${{ github.run_id }}-${{ github.run_attempt }}"
              git checkout -b "$NEWBR" "origin/$WTBR"
              git push -u origin "$NEWBR"
              if command -v gh >/dev/null 2>&1; then
                gh pr create --base "$BASE" --head "$NEWBR" \
                  --title "Enigma bulk expansion (run ${{ github.run_id }})" \
                  --body "Auto-generated bulk folder expansion. Please review and merge."
              else
                echo "[PR][WARN] gh CLI not found; pushed branch $NEWBR"
              fi
            else
              git push origin "$BASE"
            fi
          fi

      - name: Resident-batch (daemon mode; within runner limit)
        if: env.DAEMON_PROFILE != 'off'
        run: |
          set -Eeuo pipefail
          WDIR="${{ steps.workdir.outputs.workdir }}"
          WTBR="${{ steps.workdir.outputs.worktree_branch }}"
          BASE="${{ steps.workdir.outputs.base_branch }}"
          cd "$WDIR"

          case "${DAEMON_PROFILE:-normal}" in
            fast)   INTERVAL=60;   DURATION_MIN=60 ;;   # 1분 / 1시간
            normal) INTERVAL=300;  DURATION_MIN=180 ;;  # 5분 / 3시간
            slow)   INTERVAL=900;  DURATION_MIN=360 ;;  # 15분 / 6시간
            *)      INTERVAL=300;  DURATION_MIN=180 ;;
          esac

          echo "[DAEMON] profile=$DAEMON_PROFILE interval=$INTERVAL sec duration=$DURATION_MIN min"
          END_AT=$(( $(date +%s) + DURATION_MIN*60 ))
          iter=0

          while [ "$(date +%s)" -lt "$END_AT" ]; do
            iter=$((iter+1))
            echo "[DAEMON][$iter] expand + push"
            BASE_PATH="${BASE_PATH:-.github/echo_enigma}" TOTAL_DIRS="${TOTAL_DIRS:-500}" DEPTH="${DEPTH:-3}" \
            FANOUT="${FANOUT:-5}" FILES_PER_DIR="${FILES_PER_DIR:-1}" \
            REPORT_DIR="site/reports" LOG_DIR=".github/echo_enigma/logs" ./scripts/enigma_expand.sh

            if git diff --quiet; then
              echo "[DAEMON][$iter] no changes"
            else
              CM="${COMMIT_MSG:-chore(enigma): bulk dir expansion + disk prep} [daemon#$iter]"
              git -c user.name="github-actions[bot]" -c user.email="github-actions[bot]@users.noreply.github.com" \
                  add -A
              git commit -m "$CM"
              git push origin "HEAD:$WTBR" || true

              cd "$GITHUB_WORKSPACE"
              git fetch origin "$BASE" "$WTBR" --prune
              git checkout "$BASE"
              git pull --ff-only origin "$BASE" || true
              git merge --ff-only "origin/$WTBR" && git push origin "$BASE" || true
              cd "$WDIR"
            fi

            sleep "$INTERVAL"
          done
          echo "[DAEMON] finished"

      - name: Cleanup worktree & temp branch
        if: always()
        run: |
          set -Eeuo pipefail
          WTDIR="/mnt/enigma-work"
          WTBR="${{ steps.workdir.outputs.worktree_branch }}"
          BASE="${{ steps.workdir.outputs.base_branch }}"

          if [ -d "$WTDIR" ]; then
            echo "[CLEAN] Removing worktree $WTDIR"
            git worktree remove -f "$WTDIR" || true
          fi
          if [ "$WTBR" != "$BASE" ]; then
            echo "[CLEAN] Deleting temp branch $WTBR (local)"
            git branch -D "$WTBR" || true
            echo "[CLEAN] Deleting temp branch $WTBR (remote)"
            git push origin --delete "$WTBR" || true
          fi

      - name: Show disk/mount after
        if: always()
        run: |
          echo "[DISK][AFTER]"; df -hT | sed 's/^/[DF] /' || true
          mount | grep enigma || true

      - name: Upload reports/artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: enigma-reports
          path: |
            **/site/reports/*.csv
            **/.github/echo_enigma/logs/*.log
            scripts/enigma_expand.sh
          if-no-files-found: ignore
